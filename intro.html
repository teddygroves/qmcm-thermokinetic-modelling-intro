<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.330">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Bayesian inference for realistic thermokinetic models of cell metabolism</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="intro_files/libs/clipboard/clipboard.min.js"></script>
<script src="intro_files/libs/quarto-html/quarto.js"></script>
<script src="intro_files/libs/quarto-html/popper.min.js"></script>
<script src="intro_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="intro_files/libs/quarto-html/anchor.min.js"></script>
<link href="intro_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="intro_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="intro_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="intro_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="intro_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#our-modelling-approach" id="toc-our-modelling-approach" class="nav-link active" data-scroll-target="#our-modelling-approach">Our modelling approach</a>
  <ul class="collapse">
  <li><a href="#sec-generative-model" id="toc-sec-generative-model" class="nav-link" data-scroll-target="#sec-generative-model">Our generative model</a>
  <ul class="collapse">
  <li><a href="#sec-thermokinetic-models-in-general" id="toc-sec-thermokinetic-models-in-general" class="nav-link" data-scroll-target="#sec-thermokinetic-models-in-general">Thermokinetic models in general</a></li>
  <li><a href="#sec-our-thermokinetic-model" id="toc-sec-our-thermokinetic-model" class="nav-link" data-scroll-target="#sec-our-thermokinetic-model">Our thermokinetic model</a></li>
  <li><a href="#sec-" id="toc-sec-" class="nav-link" data-scroll-target="#sec-">Steady state assumption</a></li>
  <li><a href="#sec-our-full-generative-model" id="toc-sec-our-full-generative-model" class="nav-link" data-scroll-target="#sec-our-full-generative-model">Our full generative model</a></li>
  </ul></li>
  <li><a href="#sec-measurement-model" id="toc-sec-measurement-model" class="nav-link" data-scroll-target="#sec-measurement-model">Measurement model</a></li>
  <li><a href="#sec-prior-model" id="toc-sec-prior-model" class="nav-link" data-scroll-target="#sec-prior-model">Prior model</a></li>
  <li><a href="#sec-implementation" id="toc-sec-implementation" class="nav-link" data-scroll-target="#sec-implementation">Implementation</a>
  <ul class="collapse">
  <li><a href="#sec-input-specification" id="toc-sec-input-specification" class="nav-link" data-scroll-target="#sec-input-specification">Input specification</a></li>
  <li><a href="#sec-posterior-sampling" id="toc-sec-posterior-sampling" class="nav-link" data-scroll-target="#sec-posterior-sampling">Posterior sampling</a></li>
  <li><a href="#sec-solving-the-steady-state-problem" id="toc-sec-solving-the-steady-state-problem" class="nav-link" data-scroll-target="#sec-solving-the-steady-state-problem">Solving the steady state problem</a></li>
  <li><a href="#sec-analysis-of-results" id="toc-sec-analysis-of-results" class="nav-link" data-scroll-target="#sec-analysis-of-results">Analysis of results</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#our-problems" id="toc-our-problems" class="nav-link" data-scroll-target="#our-problems">Our problems</a>
  <ul class="collapse">
  <li><a href="#sec-problem-1-speed" id="toc-sec-problem-1-speed" class="nav-link" data-scroll-target="#sec-problem-1-speed">Problem 1: speed</a></li>
  <li><a href="#sec-problem-2-conservation-relationships" id="toc-sec-problem-2-conservation-relationships" class="nav-link" data-scroll-target="#sec-problem-2-conservation-relationships">Problem 2: conservation relationships</a></li>
  </ul></li>
  <li><a href="#sec-potential-solutions" id="toc-sec-potential-solutions" class="nav-link" data-scroll-target="#sec-potential-solutions">Potential solutions</a>
  <ul class="collapse">
  <li><a href="#sec-hardware" id="toc-sec-hardware" class="nav-link" data-scroll-target="#sec-hardware">Hardware</a></li>
  <li><a href="#sec-compiler" id="toc-sec-compiler" class="nav-link" data-scroll-target="#sec-compiler">Compiler</a></li>
  <li><a href="#sec-ode-solver-tolerances" id="toc-sec-ode-solver-tolerances" class="nav-link" data-scroll-target="#sec-ode-solver-tolerances">ODE solver tolerances</a></li>
  <li><a href="#sec-adjoint-ode-solver" id="toc-sec-adjoint-ode-solver" class="nav-link" data-scroll-target="#sec-adjoint-ode-solver">Adjoint ODE solver</a></li>
  <li><a href="#sec-algebra-solver" id="toc-sec-algebra-solver" class="nav-link" data-scroll-target="#sec-algebra-solver">Algebra solver</a></li>
  <li><a href="#sec-starting-concentraion-vector" id="toc-sec-starting-concentraion-vector" class="nav-link" data-scroll-target="#sec-starting-concentraion-vector">Starting concentration vector</a></li>
  <li><a href="#sec-dae-system" id="toc-sec-dae-system" class="nav-link" data-scroll-target="#sec-dae-system">DAE system</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="intro.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li><li><a href="intro.docx"><i class="bi bi-file-word"></i>MS Word</a></li></ul></div></nav>
</div>
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Bayesian inference for realistic thermokinetic models of cell metabolism</h1>
<p class="subtitle lead">What we want to do and where we need help</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>This document explains how our group, Quantitative Modelling of Cell Metabolism, thinks about modelling networks of metabolic reactions. It also explains where we think our approach could be improved and what kind of help we need in order to carry out these improvements.</p>
<section id="our-modelling-approach" class="level1 page-columns page-full">
<h1>Our modelling approach</h1>
<p>Our aim is to synthesise information from the following sources:</p>
<ul>
<li>Quantitative measurements of the cell’s metabolites, enzymes and fluxes</li>
<li>A thermokinetic model that describes how each reaction in the metabolic network works in terms of some unknown parameters.</li>
<li>Quantitative information about the parameters of the thermokinetic model.</li>
</ul>
<p>We believe that taking all of this information into account at the same time will yield insights that can be used to guide the design of new cell strains.</p>
<p>By treating this problem as a case of Bayesian statistical inference, we can conveniently partition these information sources into separate sub-models:</p>
<ul>
<li>A measurement model or ‘likelihood’ describing what is learned from any measurement.</li>
<li>A generative model, encompassing our thermokinetic model, that describes how measureable quantities are generated from underlying unobserved parameters.</li>
<li>A prior model describing what is known about the unobserved parameters.</li>
</ul>
<p>The rest of this section sets out how we flesh out these sub-models, starting with the generative model as it is by far the most interesting.</p>
<section id="sec-generative-model" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-generative-model">Our generative model</h2>
<section id="sec-thermokinetic-models-in-general" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-thermokinetic-models-in-general">Thermokinetic models in general</h3>
<div class="page-columns page-full"><p>A thermokinetic model describes the rates (usually referred to as ‘fluxes’) of the chemical reactions in a metabolic network parametrically, in terms of the concentrations of the network’s metabolites, some kinetic parameters describing the network’s reactions, some thermodynamic parameters and some parameters describing the network’s boundary conditions. <a href="#eq-thermokinetic-general">Equation&nbsp;1</a> therefore captures the general form of a thermokinetic model:<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;In <a href="#eq-thermokinetic-general">Equation&nbsp;1</a>, the term <span class="math inline">\(x\)</span> represents a vector of metabolite concentrations, the term represent parameter vectors, and <span class="math inline">\(v\)</span> is a vector of real numbers, one per reaction</p></li></div></div>
<p><span id="eq-thermokinetic-general"><span class="math display">\[
  v = f_v(x, \theta)
\tag{1}\]</span></span></p>
<p>Thermokinetic models of cell metabolism are often contrasted with constraint-based models. Constraint-based models do not describe metabolic fluxes parametrically; instead they simply identify constraints that exclude certain flux values.</p>
<p>Many thermokinetic models are possible, depending on how the modeller trades off detail against other factors such as computational feasibility, model identification and ease of curation.</p>
<p>One thing that almost all thermokinetic models have in common is the assumption that the stoichiometric coefficient—that is, the number of molecules created or destroyed—of every metabolite in every reaction is known and collected in a stoichiometric matrix <span class="math inline">\(S\)</span> with a row for each metabolite and a column for each reaction.</p>
</section>
<section id="sec-our-thermokinetic-model" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-our-thermokinetic-model">Our thermokinetic model</h3>
<p>The thermokinetic model that we chose decomposes into factors as shown in <a href="#eq-flux-decomposition">Equation&nbsp;2</a>. The full model is presented here for completeness and to illustrate the general nature of the equations that we use, but the details can safely be skipped over.</p>
<p><span id="eq-flux-decomposition"><span class="math display">\[
  f_v(x, \theta) = Enzyme \cdot k_{cat} \cdot Reversibility \cdot Saturation \cdot Allostery \cdot Phosphorylation
\tag{2}\]</span></span></p>
<p>Each of the terms on the right hand side of <a href="#eq-flux-decomposition">Equation&nbsp;2</a> is a function of <span class="math inline">\(x\)</span> and <span class="math inline">\(\theta\)</span> representing a conceptually distinct aspect of how an enzyme-catalysed reaction works.</p>
<p>The term <span class="math inline">\(Enzyme\)</span> is a vector of non-negative real numbers representing the concentration of the enzyme catalysing each reaction.</p>
<p>The term <span class="math inline">\(k_{cat}\)</span> is a vector of non-negative real numbers representing the amount of flux carried per unit of saturated enzyme.</p>
<div class="page-columns page-full"><p>The term <span class="math inline">\(Reversibility\)</span> is a vector of real numbers capturing the impact of thermodynamics on the reaction’s flux, as shown in <a href="#eq-reversibility">Equation&nbsp;3</a>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p><div class="no-row-height column-margin column-container"><li id="fn2"><p><sup>2</sup>&nbsp;<a href="#eq-reversibility">Equation&nbsp;3</a> is simplified a bit; the formulation we use in practice takes into account special cases where a reactions that consumes or produces water or is affected by membrane potential. See <a href="https://github.com/biosustain/Maud/blob/b343c64979752700fff84a7b2d2e163d69060b34/src/maud/stan/functions.stan#L161">here</a> for the code that is actually used.</p></li></div></div>
<p><span id="eq-reversibility"><span class="math display">\[
\begin{aligned}
  Reversibility &amp;= 1 - \exp(\frac{\Delta_{r}G' + RT \cdot S^T \ln(x)}{RT}) \\
  \Delta_{r}G' &amp;= S^{T}\Delta_{f}G'
\end{aligned}
\tag{3}\]</span></span></p>
<p>In <a href="#eq-reversibility">Equation&nbsp;3</a> the term <span class="math inline">\(T\)</span> represents the temperature in Kelvin, <span class="math inline">\(R\)</span> is the gas constant, <span class="math inline">\(\Delta_rG'\)</span> is a vector representing the Gibbs free energy change of each reaction in standard conditions and <span class="math inline">\(\Delta_fG'\)</span> is a vector representing the standard condition Gibbs free energy change of each metabolite’s formation reaction, or in other words each metabolite’s ‘formation energy’.</p>
<p>Note that the thermodynamic effect on each reaction is derived from metabolite formation energies. This formulation is helpful because, provided that all reactions’ rates are calculated from the same formation energies, they are guaranteed to be thermodynamically consistent.</p>
<p>The term <span class="math inline">\(Saturation\)</span> in equation <a href="#eq-flux-decomposition">Equation&nbsp;2</a> is a vector of non-negative real numbers representing, for each reaction, the fraction of enzyme that is saturated, i.e.&nbsp;bound to one of the reaction’s substrates. To describe saturation we use <a href="#eq-saturation">Equation&nbsp;4</a>, which is taken from <span class="citation" data-cites="liebermeisterModularRateLaws2010">Liebermeister, Uhlendorf, and Klipp (<a href="#ref-liebermeisterModularRateLaws2010" role="doc-biblioref">2010</a>)</span>.</p>
<p><span id="eq-saturation"><span class="math display">\[
\begin{aligned}
  Saturation_r &amp;= a \cdot \text{free enzyme ratio} \\
             a &amp;= \prod_{\text{s substrate}}\frac{x_s}{km_{rs}} \\
\text{free enzyme ratio} &amp;= \begin{cases}
                  \prod_{\text{s sustrate}} (\frac{x_s}{km_{rs}})^{S_sr}
                  + \sum_{\text{c inhibitor}}\frac{x_c}{ki_{rc}} &amp; r\text{ irreversible} \\
                  -1
                  + \prod_{\text{s sustrate}} (\frac{x_s}{km_{rs}})^{S_sr}
                  + \sum_{\text{c inhibitor}}\frac{x_c}{ki_{rc}}
                  + \prod_{\text{p product}} (\frac{x_p}{km_{rp}})^{S_pr}  &amp; r\text{ reversible}
                  \end{cases}
\end{aligned}
\tag{4}\]</span></span></p>
<p>The term <span class="math inline">\(Allostery\)</span> in <a href="#eq-flux-decomposition">Equation&nbsp;2</a> is a vector of non-negative numbers describing the effect of allosteric regulation on each reaction. Allosteric regulation happens when binding to a certain molecule changes an enzyme’s shape in a way that changes its catalytic behaviour. We use <a href="#eq-allostery">Equation&nbsp;5</a>, originally from <span class="citation" data-cites="popovaGeneralizationModelMonod1975">Popova and Sel’kov (<a href="#ref-popovaGeneralizationModelMonod1975" role="doc-biblioref">1975</a>)</span>, to describe this phenomenon.</p>
<p><span id="eq-allostery"><span class="math display">\[
\begin{aligned}
  Allostery_r &amp;= \frac{1}{1 + tc_r \cdot (\text{free enzyme ratio}_r \cdot \frac{Qtense}{Qrelaxed})^{subunits}} \\
       Qtense &amp;= 1 + \sum_{\text{i inhibitor}} \frac{x_i}{dc_{ri}} \\
     Qrelaxed &amp;= 1 + \sum_{\text{a activator}} \frac{x_a}{dc_{ra}}
\end{aligned}
\tag{5}\]</span></span></p>
<p>Finally, the term <span class="math inline">\(Phosphorylation\)</span> in <a href="#eq-flux-decomposition">Equation&nbsp;2</a> captures an important effect whereby enzyme activity is altered due to a coupled process of phosphorylation and dephosphorylation.</p>
<p><span id="eq-phosphorylation"><span class="math display">\[
\begin{aligned}
Phosphorylation_r &amp;= (\frac{\beta}{\alpha + \beta})^{subunits} \\
          \alpha &amp;= \sum_{\text{p phosphoylator}} kcat_{p} \cdot concp_p \\
           \beta &amp;= \sum_{\text{p dephosphoylator}} kcat_{d} \cdot concd_d \\
\end{aligned}
\tag{6}\]</span></span></p>
</section>
<section id="sec-" class="level3">
<h3 class="anchored" data-anchor-id="sec-">Steady state assumption</h3>
<p>As well as assuming that the fluxes in our metabolic network will behave as our thermokinetic model expects, we also assume that the system was measured in a steady state, so that every non-boundary metabolite’s concentration was not changing. This assumption is represented mathematically in <a href="#eq-steady">Equation&nbsp;7</a>.</p>
<p><span id="eq-steady"><span class="math display">\[
S\cdot f_v(x, \theta) = 0
\tag{7}\]</span></span></p>
<p>The steady state assumption removes degrees of freedom equal to the rank of <span class="math inline">\(S\)</span> from our model, so that <span class="math inline">\(v\)</span> is constrained to lie in the right null space of S. Usually, given <span class="math inline">\(\theta\)</span> it is possible can solve <a href="#eq-steady">Equation&nbsp;7</a> to find a steady state metabolite concentration <span class="math inline">\(x_{steady}\)</span>.</p>
</section>
<section id="sec-our-full-generative-model" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-our-full-generative-model">Our full generative model</h3>
<div class="page-columns page-full"><p>Our full generative model starts with a parameter vector <span class="math inline">\(\theta\)</span>. It then calculates the steady state metabolite concentration vector <span class="math inline">\(x_steady\)</span> by solving <span class="math inline">\(@eq-steady\)</span>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Metabolite concentrations are now available and can be compared with measurements. To find flux values to compare with measurements we simply calculate <span class="math inline">\(v_{steady}=f_v(x_{steady}, \theta)\)</span>.</p><div class="no-row-height column-margin column-container"><li id="fn3"><p><sup>3</sup>&nbsp;Note that in practice we do not solve <a href="#eq-steady">Equation&nbsp;7</a> directly but instead use ODE simulation - see section <a href="#sec-solving-the-steady-state-problem">Section&nbsp;1.4.3</a> for details</p></li></div></div>
</section>
</section>
<section id="sec-measurement-model" class="level2">
<h2 class="anchored" data-anchor-id="sec-measurement-model">Measurement model</h2>
<p>For measurements of metabolite and enzyme concentrations we use independent lognormal regression models:</p>
<p><span id="eq-conc-measurement-model"><span class="math display">\[
\begin{aligned}
  y_{x} &amp;\sim LN(\ln(x_{steady}), \sigma_x) \\
  y_{enzyme} &amp;\sim LN(\ln(Enzyme), \sigma_{enzyme})
\end{aligned}
\tag{8}\]</span></span></p>
<p>For measurements of steady state fluxes we use independent linear regression models:</p>
<p><span class="math display">\[\begin{equation}
  y_{v} \sim N(f_v(x_{steady}, \theta), \sigma_v)
\end{equation}\]</span>{#eq-conc-measurement-model}</p>
<p>We ensure that flux measurements correspond to the flux modes of the measured network, so that the same pathway is never measured twice. See chapter 10 of <span class="citation" data-cites="palssonSystemsBiologyConstraintbased2015">Palsson (<a href="#ref-palssonSystemsBiologyConstraintbased2015" role="doc-biblioref">2015</a>)</span>, entitled “the left null space” for a discussion of this issue.</p>
<p>We assume that the measurement errors <span class="math inline">\(\sigma_x\)</span>, <span class="math inline">\(\sigma_{enzyme}\)</span> and <span class="math inline">\(\sigma_v\)</span> are known for each measurement.</p>
<p>These measurements <span class="math inline">\(y_x\)</span> and <span class="math inline">\(y_{enzyme}\)</span> are typically derived from quantitative metabolomics and proteomics experiments. Our choice of measurement model for these measurements is imperfect in at least these ways:</p>
<ul>
<li>The measurement error is not known, and is in fact very difficult to estimate.</li>
<li>The measurements are not independent, as they are typically far more reliable as to differences—both between metabolites in the same experiment and between the same metabolite in different experiments—than they are as to absolute concentrations.</li>
</ul>
<p>These problems also apply to flux measurements, but there is another issue: flux meausrements are derived from k</p>
</section>
<section id="sec-prior-model" class="level2">
<h2 class="anchored" data-anchor-id="sec-prior-model">Prior model</h2>
<p>For kinetic parameters including <span class="math inline">\(km\)</span>, <span class="math inline">\(kcat\)</span>, <span class="math inline">\(ki\)</span> and parameters governing regulation we use independent informative lognormal prior distributions based on information gleaned from online databases, literature searches and intuition.</p>
<p>For boundary conditions including unbalanced metabolite concentrations, boundary fluxes and enzyme concentrations we use informative independent lognormal or normal prior distributions depending on the natural sign constraints of the variable (for example fluxes are not constrained to be positive, so in this case we use independent normal prior distributions). We sometimes use measurements to determine informative prior distributions for boundary conditions.</p>
<p>For thermodynamic parameters—i.e.&nbsp;metabolite formation energies—we use an informative multivariate normal distribution that is derived from equilibrium constant measurements reported in the NIST TECRDB <span class="citation" data-cites="goldbergThermodynamicsEnzymecatalyzedReactions2004">Goldberg, Tewari, and Bhat (<a href="#ref-goldbergThermodynamicsEnzymecatalyzedReactions2004" role="doc-biblioref">2004</a>)</span>. The distribution is calculated using the component contribution method <span class="citation" data-cites="noorConsistentEstimationGibbs2013">Noor et al. (<a href="#ref-noorConsistentEstimationGibbs2013" role="doc-biblioref">2013</a>)</span> as implemented in the software equilibrator <span class="citation" data-cites="beberEQuilibratorPlatformEstimation2021">Beber et al. (<a href="#ref-beberEQuilibratorPlatformEstimation2021" role="doc-biblioref">2021</a>)</span>. In future we would like to use our own software to generate these priors.</p>
</section>
<section id="sec-implementation" class="level2">
<h2 class="anchored" data-anchor-id="sec-implementation">Implementation</h2>
<p>Full details of how we implement Bayesian thermokinetic modelling can be found in our software package <a href="https://github.com/biosustain/Maud">Maud</a>.</p>
<section id="sec-input-specification" class="level3">
<h3 class="anchored" data-anchor-id="sec-input-specification">Input specification</h3>
<p>The required input for our Bayesian thermokinetic model is as follows:</p>
<ul>
<li>A qualititative specification of the thermokinetic model, including reaction stoichiometries, enzyme and compartment mappings and regulations.</li>
<li>Records of experiments including measurements (and their errors) and enzyme knockouts.</li>
<li>Information about parameters including priors and initial values. In future it will also be possible to fix a parameter’s value.</li>
<li>Configuration including MCMC hyperparameters, solver tolerances and units.</li>
</ul>
<p>We created a custom format with which these things can be specified in <a href="https://toml.io/en/">toml</a> files. Maud can read these files, perform validation and represent them as Python objects.</p>
</section>
<section id="sec-posterior-sampling" class="level3">
<h3 class="anchored" data-anchor-id="sec-posterior-sampling">Posterior sampling</h3>
<p>We carry out Bayesian inference by posterior sampling using adaptive Hamiltonian Monte Carlo as provided by <a href="https://mc-stan.org/">Stan</a>.</p>
<p>To our knowledge this is the only viable approach. Realistic models have too many parameters for many Bayesian computation approaches, including rejection sampling, ABC, Metropolis-Hastings and Gibbs sampling, while a similar study <span class="citation" data-cites="st.johnBayesianInferenceMetabolic2018">St. John et al. (<a href="#ref-st.johnBayesianInferenceMetabolic2018" role="doc-biblioref">2018</a>)</span> indicates that variational inference is unlikely to provide satisfactory approximations in this case.</p>
<p>We believe that the non-linear, multi-parameter equations shown in <a href="#sec-our-thermokinetic-model">Section&nbsp;1.1.2</a> create particular problems for MCMC sampling because they induce complex correlations in the posterior distribution. Consequently, although adaptive Hamiltonian Monte Carlo makes Bayesian inference for realistic thermokinetic models possible, many leapfrog steps are typically required per sample, as the sampler must traverse the posterior distribution in small steps in order to avoid discretisation errors.</p>
</section>
<section id="sec-solving-the-steady-state-problem" class="level3">
<h3 class="anchored" data-anchor-id="sec-solving-the-steady-state-problem">Solving the steady state problem</h3>
<p>As mentioned in <a href="#sec-our-full-generative-model">Section&nbsp;1.1.4</a>, in our generative model steady state metabolite concentrations are calculated from parameter values by solving the steady state equation <a href="#eq-steady">Equation&nbsp;7</a>. Since adaptive Hamiltonian Monte Carlo requires gradients of the posterior distribution, it is also necessary to calculate sensitivities of the steady state problem solution with respect to all parameters.</p>
<p>Our approach to this problem is to choose a starting concentration vector <span class="math inline">\(x_{0}\)</span> and a simulation time <span class="math inline">\(t\)</span>, then find <span class="math inline">\(x_t\)</span> using numerical ODE integration. To verify whether <span class="math inline">\(x_t\)</span> is a steady state we then evaluate <span class="math inline">\(S\cdot f_v(x_t, \theta)\)</span> and check if the result is sufficiently close to zero.</p>
<p>Stan provides an interface to the Sundials ODE solver CVODES, including gradient calculations.</p>
<p>For the systems we have investigated, this method works better than solving the steady state problem using an algebra solver.</p>
</section>
<section id="sec-analysis-of-results" class="level3">
<h3 class="anchored" data-anchor-id="sec-analysis-of-results">Analysis of results</h3>
<p>After sampling is complete, Maud uses the Bayesian analysis library <a href="https://python.arviz.org/en/0.14.0/index.html">arviz</a> to transform the results into an <a href="https://python.arviz.org/en/0.14.0/api/inference_data.html">InferenceData</a> object and save it as a json file, along with a range of files containing debug information. These files can be used to validate the computation and to draw conclusions about the measured system.</p>
</section>
</section>
</section>
<section id="our-problems" class="level1 page-columns page-full">
<h1>Our problems</h1>
<p>There are several features we would like to add to Maud in order to model new phenomena, including promiscuous enzymes, varying compartment volumes and different enzyme mechanisms. In addition, as mentioned above our measurement models are somewhat unrealistic and should ideally be replaced with models that more accurately reflect the information contained in a multi-omics analysis, particularly in the case of data from 13C labelling experiments. There are also new features that would make the modelling process easier, including fixing arbitrary parameters values, automatically loading input data and adding more validation. We are pretty confident that we can incrementally add all these features within the current framework.</p>
<p>However our biggest problems require more fundamental changes: we would like to fit larger networks faster, and we would like to guarantee that our models appropriately respect known conservation relationships.</p>
<section id="sec-problem-1-speed" class="level2">
<h2 class="anchored" data-anchor-id="sec-problem-1-speed">Problem 1: speed</h2>
<p>Due to speed constraints, the ballpark range for the largest systems we can practically model is around 15 reactions and state variables: see <a href="https://github.com/biosustain/Maud/tree/master/src/maud/data/example_inputs/methionine">the example maud input for the methionine cycle</a> for an illustration. This is large enough that Maud can describe some non-trivial metabolic networks, but relatively small improvements would dramatically expand the range of applicability. To illustrate, it is possible to describe the important subsystem comprising glycolysis and pentose phosphate pathway in <em>E. coli</em> using about 20 reactions, and <a href="http://bigg.ucsd.edu/models/e_coli_core"><code>e_coli_core</code></a>, the smallest model in the UCSD BIGG database, has 95 reactions.</p>
<p>The main thing that limits Maud’s speed is the need to solve the steady state problem many times. To illustrate, a typical run with 2000 iterations, each with 500 gradient evaluations requires the steady state problem to be solved 1000000 times.</p>
</section>
<section id="sec-problem-2-conservation-relationships" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-problem-2-conservation-relationships">Problem 2: conservation relationships</h2>
<p>Conservation relationships exist when a network conserves the total abundance of a combination of metabolites. For example, central carbon metabolism does not change the total amount of the metabolites ATP, AMP and ADP, but only changes the distribution of the total pool among these three forms. In general any concentration vector <span class="math inline">\(x\)</span> must satsify a set of mass conservation equations</p>
<p><span class="math display">\[\begin{equation}
L\cdot vol(x) = a
\end{equation}\]</span>{#eq-conservation}</p>
<div class="page-columns page-full"><p>where <span class="math inline">\(L\)</span> is the left null space of the stoichiometric matrix (i.e.&nbsp;a matrix satisfying <span class="math inline">\(L\cdot S = 0\)</span>), <span class="math inline">\(vol\)</span> is a function that translates concentrations into abundances and <span class="math inline">\(a\)</span> is a vector of pool abundances.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p><div class="no-row-height column-margin column-container"><li id="fn4"><p><sup>4</sup>&nbsp;See chapter 10 (‘The Left Null Space of S’) of <span class="citation" data-cites="palssonSystemsBiologyConstraintbased2015">Palsson (<a href="#ref-palssonSystemsBiologyConstraintbased2015" role="doc-biblioref">2015</a>)</span> for further discussion.</p></li></div></div>
<div class="page-columns page-full"><p>The practical importance of conservation relationships for our problem is that, in our current implementation, the vector <span class="math inline">\(a\)</span> is fixed by the starting metabolite concentration, which is effectively hard-coded<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. If it is inappropriate—for example if due to insufficient total ATP, AMP and ADP a reaction cannot flow in the correct direction—there is no way for the model to correct for this. We therefore think there are cases where our implementation prevents a steady state from being found even though one exists.</p><div class="no-row-height column-margin column-container"><li id="fn5"><p><sup>5</sup>&nbsp;To be precise the starting concentration for each metabolite is set before sampling as either the measured value if available or a default value</p></li></div></div>
</section>
</section>
<section id="sec-potential-solutions" class="level1">
<h1>Potential solutions</h1>
<section id="sec-hardware" class="level2">
<h2 class="anchored" data-anchor-id="sec-hardware">Hardware</h2>
<p>We have not been able to improve Maud’s performance dramatically by using high performance computers or by exploiting parallelism as the key bottlenecks—it is difficult to ensure steady state solving.</p>
</section>
<section id="sec-compiler" class="level2">
<h2 class="anchored" data-anchor-id="sec-compiler">Compiler</h2>
<p>Another possibility is to explore compiler optimisations as described <a href="https://blog.mc-stan.org/2022/08/03/options-for-improving-stan-sampling-speed/">here</a>. We have not had much success, though there is definitely room for further optimisation in this area.</p>
</section>
<section id="sec-ode-solver-tolerances" class="level2">
<h2 class="anchored" data-anchor-id="sec-ode-solver-tolerances">ODE solver tolerances</h2>
<p>There is a dramatic change in speed depending on the chosen ODE solver tolerances. We have not been able to find a systematic way to choose these, so we let the user configure these per run.</p>
</section>
<section id="sec-adjoint-ode-solver" class="level2">
<h2 class="anchored" data-anchor-id="sec-adjoint-ode-solver">Adjoint ODE solver</h2>
<p>Stan provides an interface to <a href="https://mc-stan.org/docs/2_31/stan-users-guide/adjoint-ode.html">the CVODE bdf solver with gradients calculated using adjoint sensitivity analysis</a> (the default approach, which we use, instead calculates gradients by solving an augmented ODE system). We expected using this solver to lead to improved speed and tried to use it when it was released, but we were not able to achieve large improvements, and reliability was worse.</p>
</section>
<section id="sec-algebra-solver" class="level2">
<h2 class="anchored" data-anchor-id="sec-algebra-solver">Algebra solver</h2>
<p>It is possible in principle to solve the steady state problem using an algebra solver rather than via our forward simulation method. We have not been able to make this approach work reliably as the available solvers require a good starting guess.</p>
</section>
<section id="sec-starting-concentraion-vector" class="level2">
<h2 class="anchored" data-anchor-id="sec-starting-concentraion-vector">Starting concentration vector</h2>
<p>A clear problem with our approach to solving the steady state problem is that we use a bad starting metabolite concentration vector. There are several potential speed improvements from choosing the starting concentration with escalating potential for improvement (and difficulty):</p>
<ol type="1">
<li>Find a better starting concentration vector before beginning MCMC and use the better starting concentration vector the same way we use our current one.</li>
<li>Use the warmup MCMC iterations to improve the starting concentration vector, then use the improved vector for the sampling iterations.</li>
<li>Choose a new starting vector every MCMC iteration or every few iterations.</li>
<li>Choose a new starting concentration vector programmatically on each gradient evaluation based on current parameter values.</li>
<li>Choose a new starting concentration vector on each gradient evaluation based on the result of the previous gradient evaluation.</li>
</ol>
<p>Option 1 could be achieved simply by substituting the code that chooses the starting concentration for a better alternative.</p>
<p>Options 2 and 3 require running Stan multiple times with custom starting conditions. This isn’t a huge challenge.</p>
<p>Option 4 is easy in principle as it only requires writing some Stan code. However we don’t know how to use the current parameter values to find a good starting concentration.</p>
<p>Option 5 is difficult as it requires re-writing Stan’s underlying C++ code.</p>
</section>
<section id="sec-dae-system" class="level2">
<h2 class="anchored" data-anchor-id="sec-dae-system">DAE system</h2>
<p>We think the correct way to take into account conservation relationsips is to cast the steady state problem as a differential algebraic equation system.</p>
<p>Stan provides an <a href="https://mc-stan.org/docs/functions-reference/functions-dae-solver.html">interface to the Sundials IDAS DAE solver</a>.</p>
</section>
</section>
<section id="references" class="level1 unnumbered">


</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-beberEQuilibratorPlatformEstimation2021" class="csl-entry" role="listitem">
Beber, Moritz E., Mattia G. Gollub, Dana Mozaffari, Kevin M. Shebek, and Elad Noor. 2021. <span>“<span class="nocase">eQuilibrator</span> 3.0 – a Platform for the Estimation of Thermodynamic Constants.”</span> <em>arXiv:2103.00621 [q-Bio]</em>, February. <a href="http://arxiv.org/abs/2103.00621">http://arxiv.org/abs/2103.00621</a>.
</div>
<div id="ref-goldbergThermodynamicsEnzymecatalyzedReactions2004" class="csl-entry" role="listitem">
Goldberg, Robert N., Yadu B. Tewari, and Talapady N. Bhat. 2004. <span>“Thermodynamics of Enzyme-Catalyzed Reactionsa Database for Quantitative Biochemistry.”</span> <em>Bioinformatics</em> 20 (16): 2874–77. <a href="https://doi.org/10.1093/bioinformatics/bth314">https://doi.org/10.1093/bioinformatics/bth314</a>.
</div>
<div id="ref-liebermeisterModularRateLaws2010" class="csl-entry" role="listitem">
Liebermeister, Wolfram, Jannis Uhlendorf, and Edda Klipp. 2010. <span>“Modular Rate Laws for Enzymatic Reactions: Thermodynamics, Elasticities and Implementation.”</span> <em>Bioinformatics</em> 26 (12): 1528–34. <a href="https://doi.org/10.1093/bioinformatics/btq141">https://doi.org/10.1093/bioinformatics/btq141</a>.
</div>
<div id="ref-noorConsistentEstimationGibbs2013" class="csl-entry" role="listitem">
Noor, Elad, Hulda S. Haraldsdóttir, Ron Milo, and Ronan M. T. Fleming. 2013. <span>“Consistent <span>Estimation</span> of <span>Gibbs Energy Using Component Contributions</span>.”</span> Edited by Daniel A. Beard. <em>PLoS Computational Biology</em> 9 (7): e1003098. <a href="https://doi.org/10.1371/journal.pcbi.1003098">https://doi.org/10.1371/journal.pcbi.1003098</a>.
</div>
<div id="ref-palssonSystemsBiologyConstraintbased2015" class="csl-entry" role="listitem">
Palsson, Bernhard Ø. 2015. <em>Systems <span>Biology</span>: <span class="nocase">Constraint-based Reconstruction</span> and <span>Analysis</span></em>. <span>Cambridge</span>: <span>Cambridge University Press</span>. <a href="https://doi.org/10.1017/CBO9781139854610">https://doi.org/10.1017/CBO9781139854610</a>.
</div>
<div id="ref-popovaGeneralizationModelMonod1975" class="csl-entry" role="listitem">
Popova, S. V., and E. E. Sel’kov. 1975. <span>“Generalization of the Model by Monod, Wyman and Changeux for the Case of a Reversible Monosubstrate Reaction.”</span> <em>FEBS Letters</em> 53 (3): 269–73. <a href="https://doi.org/10.1016/0014-5793(75)80034-2">https://doi.org/10.1016/0014-5793(75)80034-2</a>.
</div>
<div id="ref-st.johnBayesianInferenceMetabolic2018" class="csl-entry" role="listitem">
St. John, Peter, Jonathan Strutz, Linda J Broadbelt, Keith E J Tyo, and Yannick J Bomble. 2018. <span>“Bayesian Inference of Metabolic Kinetics from Genome-Scale Multiomics Data.”</span> <em>bioRxiv</em>, October. <a href="https://doi.org/10.1101/450163">https://doi.org/10.1101/450163</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>