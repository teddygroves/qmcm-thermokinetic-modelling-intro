<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.330">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Bayesian inference for realistic kinetic models of cell metabolism</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="intro_files/libs/clipboard/clipboard.min.js"></script>
<script src="intro_files/libs/quarto-html/quarto.js"></script>
<script src="intro_files/libs/quarto-html/popper.min.js"></script>
<script src="intro_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="intro_files/libs/quarto-html/anchor.min.js"></script>
<link href="intro_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="intro_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="intro_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="intro_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="intro_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#our-modelling-approach" id="toc-our-modelling-approach" class="nav-link active" data-scroll-target="#our-modelling-approach">Our modelling approach</a>
  <ul class="collapse">
  <li><a href="#our-generative-model-sec-generative-mo" id="toc-our-generative-model-sec-generative-mo" class="nav-link" data-scroll-target="#our-generative-model-sec-generative-mo">Our generative model {#sec-generative-mo</a>
  <ul class="collapse">
  <li><a href="#thermokinetic-models-in-general" id="toc-thermokinetic-models-in-general" class="nav-link" data-scroll-target="#thermokinetic-models-in-general">Thermokinetic models in general</a></li>
  <li><a href="#our-thermokinetic-model" id="toc-our-thermokinetic-model" class="nav-link" data-scroll-target="#our-thermokinetic-model">Our thermokinetic model</a></li>
  <li><a href="#steady-state-assumption" id="toc-steady-state-assumption" class="nav-link" data-scroll-target="#steady-state-assumption">Steady state assumption</a></li>
  <li><a href="#our-full-generative-model" id="toc-our-full-generative-model" class="nav-link" data-scroll-target="#our-full-generative-model">Our full generative model</a></li>
  </ul></li>
  <li><a href="#sec-measurement-model" id="toc-sec-measurement-model" class="nav-link" data-scroll-target="#sec-measurement-model">Measurement model</a></li>
  <li><a href="#sec-prior-model" id="toc-sec-prior-model" class="nav-link" data-scroll-target="#sec-prior-model">Prior model</a></li>
  <li><a href="#sec-implementation" id="toc-sec-implementation" class="nav-link" data-scroll-target="#sec-implementation">Implementation</a>
  <ul class="collapse">
  <li><a href="#sec-posterior-sampling" id="toc-sec-posterior-sampling" class="nav-link" data-scroll-target="#sec-posterior-sampling">Posterior sampling</a></li>
  <li><a href="#sec-solving-the-steady-state-problem" id="toc-sec-solving-the-steady-state-problem" class="nav-link" data-scroll-target="#sec-solving-the-steady-state-problem">Solving the steady state problem</a></li>
  <li><a href="#sec-software" id="toc-sec-software" class="nav-link" data-scroll-target="#sec-software">Software</a></li>
  </ul></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="intro.ipynb" download="intro.ipynb"><i class="bi bi-journal-code"></i>Jupyter</a></li></ul></div></nav>
</div>
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Bayesian inference for realistic kinetic models of cell metabolism</h1>
<p class="subtitle lead">What we want to do and why it is tricky</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>This document explains how our group, Quantitative Modelling of Cell Metabolism, thinks about modelling networks of metabolic reactions.</p>
<section id="our-modelling-approach" class="level1 page-columns page-full">
<h1>Our modelling approach</h1>
<p>Our aim is to synthesise information from the following sources:</p>
<ul>
<li>Quantitative measurements of the cell’s metabolites, enzymes and fluxes</li>
<li>A thermokinetic model that describes how each reaction in the metabolic network works in terms of some unknown parameters.</li>
<li>Quantitative information about the parameters of the thermokinetic model.</li>
</ul>
<p>We believe that taking all of this information into account at the same time will yield insights that can be used to guide the design of new cell strains.</p>
<p>By treating this problem as a case of Bayesian statistical inference, we can conveniently partition these information sources into separate sub-models:</p>
<ul>
<li>A measurement model or ‘likelihood’ describing what is learned from any measurement.</li>
<li>A generative model, encompassing our thermokinetic model, that describes how measureable quantities are generated from underlying unobserved parameters.</li>
<li>A prior model describing what is known about the unobserved parameters.</li>
</ul>
<p>The rest of this section sets out how we flesh out these sub-models, starting with the generative model as it is by far the most interesting.</p>
<section id="our-generative-model-sec-generative-mo" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="our-generative-model-sec-generative-mo">Our generative model {#sec-generative-mo</h2>
<section id="thermokinetic-models-in-general" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="thermokinetic-models-in-general">Thermokinetic models in general</h3>
<div class="page-columns page-full"><p>A thermokinetic model describes the rates (usually referred to as ‘fluxes’) of the chemical reactions in a metabolic network parametrically, in terms of the concentrations of the network’s metabolites, some kinetic parameters describing the network’s reactions, some thermodynamic parameters and some parameters describing the network’s boundary conditions. <a href="#eq-thermokinetic-general">Equation&nbsp;1</a> therefore captures the general form of a thermokinetic model:<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;In <a href="#eq-thermokinetic-general">Equation&nbsp;1</a>, the term <span class="math inline">\(x\)</span> represents a vector of metabolite concentrations, the term represent parameter vectors, and <span class="math inline">\(v\)</span> is a vector of real numbers, one per reaction</p></li></div></div>
<p><span id="eq-thermokinetic-general"><span class="math display">\[
  v = f_v(x, \theta)
\tag{1}\]</span></span></p>
<p>Thermokinetic models of cell metabolism are often contrasted with constraint-based models. Constraint-based models do not describe metabolic fluxes parametrically; instead they simply identify constraints that exclude certain flux values.</p>
<p>Many thermokinetic models are possible, depending on how the modeller trades off detail against other factors such as computational feasibility, model identification and ease of curation.</p>
<p>One thing that almost all thermokinetic models have in common is the assumption that the stoichiometric coefficient—that is, the number of molecules created or destroyed—of every metabolite in every reaction is known and collected in a stoichiometric matrix <span class="math inline">\(S\)</span> with a row for each metabolite and a column for each reaction.</p>
</section>
<section id="our-thermokinetic-model" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="our-thermokinetic-model">Our thermokinetic model</h3>
<p>The thermokinetic model that we chose decomposes into factors as shown in <a href="#eq-flux-decomposition">Equation&nbsp;2</a>. The full model is presented here for completeness and to illustrate the general nature of the equations that we use, but the details can safely be skipped over.</p>
<p><span id="eq-flux-decomposition"><span class="math display">\[
  f_v(x, \theta) = Enzyme \cdot k_{cat} \cdot Reversibility \cdot Saturation \cdot Allostery \cdot Phosphorylation
\tag{2}\]</span></span></p>
<p>Each of the terms on the right hand side of <a href="#eq-flux-decomposition">Equation&nbsp;2</a> is a function of <span class="math inline">\(x\)</span> and <span class="math inline">\(\theta\)</span> representing a conceptually distinct aspect of how an enzyme-catalysed reaction works.</p>
<p>The term <span class="math inline">\(Enzyme\)</span> is a vector of non-negative real numbers representing the concentration of the enzyme catalysing each reaction.</p>
<p>The term <span class="math inline">\(k_{cat}\)</span> is a vector of non-negative real numbers representing the amount of flux carried per unit of saturated enzyme.</p>
<div class="page-columns page-full"><p>The term <span class="math inline">\(Reversibility\)</span> is a vector of real numbers capturing the impact of thermodynamics on the reaction’s flux, as shown in <a href="#eq-reversibility">Equation&nbsp;3</a>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p><div class="no-row-height column-margin column-container"><li id="fn2"><p><sup>2</sup>&nbsp;<a href="#eq-reversibility">Equation&nbsp;3</a> is simplified a bit; the formulation we use in practice takes into account special cases where a reactions that consumes or produces water or is affected by membrane potential. See <a href="https://github.com/biosustain/Maud/blob/b343c64979752700fff84a7b2d2e163d69060b34/src/maud/stan/functions.stan#L161">here</a> for the code that is actually used.</p></li></div></div>
<p><span id="eq-reversibility"><span class="math display">\[
\begin{aligned}
  Reversibility &amp;= 1 - \exp(\frac{\Delta_{r}G' + RT \cdot S^T \ln(x)}{RT}) \\
  \Delta_{r}G' &amp;= S^{T}\Delta_{f}G'
\end{aligned}
\tag{3}\]</span></span></p>
<p>In <a href="#eq-reversibility">Equation&nbsp;3</a> the term <span class="math inline">\(T\)</span> represents the temperature in Kelvin, <span class="math inline">\(R\)</span> is the gas constant, <span class="math inline">\(\Delta_rG'\)</span> is a vector representing the Gibbs free energy change of each reaction in standard conditions and <span class="math inline">\(\Delta_fG'\)</span> is a vector representing the standard condition Gibbs free energy change of each metabolite’s formation reaction, or in other words each metabolite’s ‘formation energy’.</p>
<p>Note that the thermodynamic effect on each reaction is derived from metabolite formation energies. This formulation is helpful because, provided that all reactions’ rates are calculated from the same formation energies, they are guaranteed to be thermodynamically consistent.</p>
<p>The term <span class="math inline">\(Saturation\)</span> in equation <a href="#eq-flux-decomposition">Equation&nbsp;2</a> is a vector of non-negative real numbers representing, for each reaction, the fraction of enzyme that is saturated, i.e.&nbsp;bound to one of the reaction’s substrates. To describe saturation we use <a href="#eq-saturation">Equation&nbsp;4</a>, which is taken from <span class="citation" data-cites="liebermeisterModularRateLaws2010">Liebermeister, Uhlendorf, and Klipp (<a href="#ref-liebermeisterModularRateLaws2010" role="doc-biblioref">2010</a>)</span>.</p>
<p><span id="eq-saturation"><span class="math display">\[
\begin{align}
  Saturation_r &amp;= a \cdot \text{free enzyme ratio} \\
             a &amp;= \prod_{\text{s substrate}}\frac{x_s}{km_{rs}} \\
\text{free enzyme ratio} &amp;= \begin{cases}
                  \prod_{\text{s sustrate}} (\frac{x_s}{km_{rs}})^{S_sr}
                  + \sum_{\text{c inhibitor}}\frac{x_c}{ki_{rc}} &amp; r\text{ irreversible} \\
                  -1
                  + \prod_{\text{s sustrate}} (\frac{x_s}{km_{rs}})^{S_sr}
                  + \sum_{\text{c inhibitor}}\frac{x_c}{ki_{rc}}
                  + \prod_{\text{p product}} (\frac{x_p}{km_{rp}})^{S_pr}  &amp; r\text{ reversible}
                  \end{cases}
\end{align}
\tag{4}\]</span></span></p>
<p>The term <span class="math inline">\(Allostery\)</span> in <a href="#eq-flux-decomposition">Equation&nbsp;2</a> is a vector of non-negative numbers describing the effect of allosteric regulation on each reaction. Allosteric regulation happens when binding to a certain molecule changes an enzyme’s shape in a way that changes its catalytic behaviour. We use <a href="#eq-allostery">Equation&nbsp;5</a>, originally from <span class="citation" data-cites="popovaGeneralizationModelMonod1975">Popova and Sel’kov (<a href="#ref-popovaGeneralizationModelMonod1975" role="doc-biblioref">1975</a>)</span>, to describe this phenomenon.</p>
<p><span id="eq-allostery"><span class="math display">\[
\begin{align}
  Allostery_r &amp;= \frac{1}{1 + tc_r + (\text{free enzyme ratio}_r \cdot \frac{Qtense}{Qrelaxed})^{subunits}} \\
       Qtense &amp;= 1 + \sum_{\text{i inhibitor}} \frac{x_i}{dc_{ri}} \\
     Qrelaxed &amp;= 1 + \sum_{\text{a activator}} \frac{x_a}{dc_{ra}}
\end{align}
\tag{5}\]</span></span></p>
<p>Finally, the term <span class="math inline">\(Phosphorylation\)</span> in <a href="#eq-flux-decomposition">Equation&nbsp;2</a> captures an important effect whereby enzyme activity is altered due to a coupled process of phosphorylation and dephosphorylation.</p>
<p><span id="eq-phosphorylation"><span class="math display">\[
\begin{align}
Phosphorylation_r &amp;= (\frac{\beta}{\alpha + \beta})^{subunits} \\
          \alpha &amp;= \sum_{\text{p phosphoylator}} kcatp_p \cdot concp_p \\
           \beta &amp;= \sum_{\text{p dephosphoylator}} kcatd_d \cdot concd_d \\
\end{align}
\tag{6}\]</span></span></p>
</section>
<section id="steady-state-assumption" class="level3">
<h3 class="anchored" data-anchor-id="steady-state-assumption">Steady state assumption</h3>
<p>As well as assuming that the fluxes in our metabolic network will behave as our thermokinetic model expects, we also assume that the system was measured in a steady state, so that every non-boundary metabolite’s concentration was not changing. This assumption is represented mathematically in <a href="#eq-steady">Equation&nbsp;7</a>.</p>
<p><span id="eq-steady"><span class="math display">\[
S\cdot f_v(x, \theta) = 0
\tag{7}\]</span></span></p>
<p>The steady state assumption removes degrees of freedom equal to the rank of <span class="math inline">\(S\)</span> from our model, so that <span class="math inline">\(v\)</span> is constrained to lie in the right null space of S. Usually, given <span class="math inline">\(\theta\)</span> it is possible can solve <a href="#eq-steady">Equation&nbsp;7</a> to find a steady state metabolite concentration <span class="math inline">\(x_{steady}\)</span>.</p>
</section>
<section id="our-full-generative-model" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="our-full-generative-model">Our full generative model</h3>
<div class="page-columns page-full"><p>Our full generative model starts with a parameter vector <span class="math inline">\(\theta\)</span>. It then calculates the steady state metabolite concentration vector <span class="math inline">\(x_{steady}\)</span> by solving <span class="math inline">\(@eq-steady\)</span>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Metabolite concentrations are now available and can be compared with measurements. To find flux values to compare with measurements we simply calculate <span class="math inline">\(v_{steady}=f_v(x_{steady}, \theta)\)</span>.</p><div class="no-row-height column-margin column-container"><li id="fn3"><p><sup>3</sup>&nbsp;Note that in practice we do not solve <a href="#eq-steady">Equation&nbsp;7</a> directly but instead use ODE simulation - see section <a href="#sec-solving-the-steady-state-problem">Section&nbsp;1.4.2</a> for details</p></li></div></div>
</section>
</section>
<section id="sec-measurement-model" class="level2">
<h2 class="anchored" data-anchor-id="sec-measurement-model">Measurement model</h2>
<p>For measurements of metabolite and enzyme concentrations we use independent lognormal regression models:</p>
<p><span id="eq-conc-measurement-model"><span class="math display">\[
\begin{align}
  y_{x} &amp;\sim LN(\ln(x_{steady}), \sigma_x) \\
  y_{enzyme} &amp;\sim LN(\ln(Enzyme), \sigma_{enzyme})
\end{align}
\tag{8}\]</span></span></p>
<p>For measurements of steady state fluxes we use independent linear regression models:</p>
<p><span id="eq-conc-measurement-model"><span class="math display">\[
\begin{equation}
  y_{v} \sim N(f_v(x_{steady}, \theta), \sigma_v)
\end{equation}
\tag{9}\]</span></span></p>
<p>We ensure that flux measurements correspond to the flux modes of the measured network, so that the same pathway is never measured twice. See chapter 10 of <span class="citation" data-cites="palssonSystemsBiologyConstraintbased2015">Palsson (<a href="#ref-palssonSystemsBiologyConstraintbased2015" role="doc-biblioref">2015</a>)</span>, entitled “the left null space” for a discussion of this issue.</p>
<p>We assume that the measurement errors <span class="math inline">\(\sigma_x\)</span>, <span class="math inline">\(\sigma_{enzyme}\)</span> and <span class="math inline">\(\sigma_v\)</span> are known for each measurement.</p>
<p>These measurements <span class="math inline">\(y_x\)</span> and <span class="math inline">\(y_{enzyme}\)</span> are typically derived from quantitative metabolomics and proteomics experiments. Our choice of measurement model for these measurements is imperfect in at least these ways:</p>
<ul>
<li>The measurement error is not known, and is in fact very difficult to estimate.</li>
<li>The measurements are not independent, as they are typically far more reliable as to differences—both between metabolites in the same experiment and between the same metabolite in different experiments—than they are as to absolute concentrations.</li>
</ul>
<p>These problems also apply to flux measurements, but there is another issue: flux meausrements are derived from k</p>
</section>
<section id="sec-prior-model" class="level2">
<h2 class="anchored" data-anchor-id="sec-prior-model">Prior model</h2>
<p>For kinetic parameters including <span class="math inline">\(km\)</span>, <span class="math inline">\(kcat\)</span>, <span class="math inline">\(ki\)</span> and parameters governing regulation we use independent informative lognormal prior distributions based on information gleaned from online databases, literature searches and intuition.</p>
<p>For boundary conditions including unbalanced metabolite concentrations, boundary fluxes and enzyme concentrations we use informative independent lognormal or normal prior distributions depending on the natural sign constraints of the variable (for example fluxes are not constrained to be positive, so in this case we use independent normal prior distributions). We sometimes use measurements to determine informative prior distributions for boundary conditions.</p>
<p>For thermodynamic parameters—i.e.&nbsp;metabolite formation energies—we use an informative multivariate normal distribution that is derived from equilibrium constant measurements reported in the NIST TECRDB <span class="citation" data-cites="goldbergThermodynamicsEnzymecatalyzedReactions2004">Goldberg, Tewari, and Bhat (<a href="#ref-goldbergThermodynamicsEnzymecatalyzedReactions2004" role="doc-biblioref">2004</a>)</span>. The distribution is calculated using the component contribution method <span class="citation" data-cites="noorConsistentEstimationGibbs2013">Noor et al. (<a href="#ref-noorConsistentEstimationGibbs2013" role="doc-biblioref">2013</a>)</span> as implemented in the software equilibrator <span class="citation" data-cites="beberEQuilibratorPlatformEstimation2021">Beber et al. (<a href="#ref-beberEQuilibratorPlatformEstimation2021" role="doc-biblioref">2021</a>)</span>. In future we would like to use our own software to generate these priors.</p>
</section>
<section id="sec-implementation" class="level2">
<h2 class="anchored" data-anchor-id="sec-implementation">Implementation</h2>
<section id="sec-posterior-sampling" class="level3">
<h3 class="anchored" data-anchor-id="sec-posterior-sampling">Posterior sampling</h3>
</section>
<section id="sec-solving-the-steady-state-problem" class="level3">
<h3 class="anchored" data-anchor-id="sec-solving-the-steady-state-problem">Solving the steady state problem</h3>
</section>
<section id="sec-software" class="level3 unnumbered">


</section>
</section>
</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">Software</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-beberEQuilibratorPlatformEstimation2021" class="csl-entry" role="listitem">
Beber, Moritz E., Mattia G. Gollub, Dana Mozaffari, Kevin M. Shebek, and Elad Noor. 2021. <span>“<span class="nocase">eQuilibrator</span> 3.0 – a Platform for the Estimation of Thermodynamic Constants.”</span> <em>arXiv:2103.00621 [q-Bio]</em>, February. <a href="http://arxiv.org/abs/2103.00621">http://arxiv.org/abs/2103.00621</a>.
</div>
<div id="ref-goldbergThermodynamicsEnzymecatalyzedReactions2004" class="csl-entry" role="listitem">
Goldberg, Robert N., Yadu B. Tewari, and Talapady N. Bhat. 2004. <span>“Thermodynamics of Enzyme-Catalyzed Reactionsa Database for Quantitative Biochemistry.”</span> <em>Bioinformatics</em> 20 (16): 2874–77. <a href="https://doi.org/10.1093/bioinformatics/bth314">https://doi.org/10.1093/bioinformatics/bth314</a>.
</div>
<div id="ref-liebermeisterModularRateLaws2010" class="csl-entry" role="listitem">
Liebermeister, Wolfram, Jannis Uhlendorf, and Edda Klipp. 2010. <span>“Modular Rate Laws for Enzymatic Reactions: Thermodynamics, Elasticities and Implementation.”</span> <em>Bioinformatics</em> 26 (12): 1528–34. <a href="https://doi.org/10.1093/bioinformatics/btq141">https://doi.org/10.1093/bioinformatics/btq141</a>.
</div>
<div id="ref-noorConsistentEstimationGibbs2013" class="csl-entry" role="listitem">
Noor, Elad, Hulda S. Haraldsdóttir, Ron Milo, and Ronan M. T. Fleming. 2013. <span>“Consistent <span>Estimation</span> of <span>Gibbs Energy Using Component Contributions</span>.”</span> Edited by Daniel A. Beard. <em>PLoS Computational Biology</em> 9 (7): e1003098. <a href="https://doi.org/10.1371/journal.pcbi.1003098">https://doi.org/10.1371/journal.pcbi.1003098</a>.
</div>
<div id="ref-palssonSystemsBiologyConstraintbased2015" class="csl-entry" role="listitem">
Palsson, Bernhard Ø. 2015. <em>Systems <span>Biology</span>: <span class="nocase">Constraint-based Reconstruction</span> and <span>Analysis</span></em>. <span>Cambridge</span>: <span>Cambridge University Press</span>. <a href="https://doi.org/10.1017/CBO9781139854610">https://doi.org/10.1017/CBO9781139854610</a>.
</div>
<div id="ref-popovaGeneralizationModelMonod1975" class="csl-entry" role="listitem">
Popova, S. V., and E. E. Sel’kov. 1975. <span>“Generalization of the Model by Monod, Wyman and Changeux for the Case of a Reversible Monosubstrate Reaction.”</span> <em>FEBS Letters</em> 53 (3): 269–73. <a href="https://doi.org/10.1016/0014-5793(75)80034-2">https://doi.org/10.1016/0014-5793(75)80034-2</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>